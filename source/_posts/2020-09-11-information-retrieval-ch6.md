---
title: chap 6-Scoring, term weighting, and the vector space model
date: 2020-09-16 00:03:26
toc: true
categories:
  - information retrieval
excerpt: 这是一篇关于《信息检索导论》第六章的读书笔记，主要学习了如何对文档进行评分和排序
---

## 参数化索引及域索引

1.  元数据：指的是和文档有关的一些具有特定形式的数据，通常包含字段和数值两部分
2.  域数据：同字段的意义相似

图示如下：

![](https://gitblog-1302688916.cos.ap-beijing.myqcloud.com/cs224n/202009/16/003116-419095.png)

另一种实现方式：

![](https://gitblog-1302688916.cos.ap-beijing.myqcloud.com/cs224n/202009/16/003155-137907.png)

### 在域索引的基础上添加权重

假定每篇文档有 l 个域，其对应的权重分别是$$g_{1}, \ldots, g_{l} \in [0,1]$$，且满足$$\sum_{i=1}^{l} g_{i}=1$$，其中$$s_{i}$$是查询文档和某个域的匹配得分（若匹配，值为1；否则，值为0），则一篇文档的查询得分为$$\sum_{i=1}^{l} g_{i} s_{i}$$

### 对于权重的学习

考虑一个简单的域加权评分的例子，其中每篇文档只包含 title 和 body 两个域。给定查询 q和文档d，根据 title 及 body 域是否和 q 匹配，利用布尔匹配函数分别计算出布尔变量$$s_{T}(d, q)$$和$$s_{B}(d, q)$$，主要接下来要确定g的值：

$$\operatorname{socre}(d, q)=g \cdot s_{T}(d, q)+(1-g) s_{B}(d, q)$$



## 词项频率及权重计算

>   目前只考虑了词项在文档中出现与否的情况，未考虑词项出现的频率。不同于之前的权重计算方法，

1.  我们认为：如果一个查询词在文档中出现的频率越高，所应该赋予的权重就越大

    此处，我们引入***词项频率（TF）***，我们使用***词袋模型***（直接将出现的次数作为权重），即不在乎词的位置，只在乎出现的次数

2.  我们认为：并不是所有词的重要性都是一样的，应该赋予不同的词以不同的权重（根据它在所有文档中出现的频繁程度，越频繁价值越低）

    此处，我们引入***逆文档频率（IDF）***，其中对于***文档频率（DF）***的定义为：词项在文档集中出现的次数（同一文档出现多次算做一次）；而IDF与DF的关系如下：

    $$i d f_{t}=\log \frac{N}{d f_{t}}$$

3.  我们通常将TF和IDF结合起来计算一个文档与查询之间的相关度，即：

    <div>$$\operatorname{tf-idf}_{t, d}=\operatorname{tf}_{t, d} \times \mathrm{idf}_{t}$$</div>
    
    当查询由多个词组成时，tf和idf用向量来表示，结果用***内积***的形式来表示；具体可见之前的一篇[博客](https://xdren69.github.io/2020/07/25/datawhale-NLP-t3/)



## 空间向量模型

一组文档的集合可以看成向量空间中的多个向量，每个词项 对应一个坐标轴。这种表示忽略了词项在文档中的相对次序。即在这种模型表示下，文档 Mary is quicker than John 和 John is quicker than Mary 是等价的

### 利用向量空间进行文档相似度的计算

此处使用余弦相似度这一计算模型：

$$\operatorname{sim}\left(d_{1}, d_{2}\right)=\frac{\vec{V}\left(d_{1}\right) \cdot \vec{V}\left(d_{2}\right)}{\left|\vec{V}\left(d_{1}\right) \| \vec{V}\left(d_{2}\right)\right|}$$

于是，将查找与 d 最相似的文档这个问题可以归结成寻找和d有最大内积结果的过程。在查询时，一般需要构建查询向量，即将查询文本视为一个短文档，并为它构建向量。



### 通过向量进行查询结果排序

>   用于给定查询，从文档集中返回得分最高的k篇文档

计算向量相似度的基本算法如下：

![](https://gitblog-1302688916.cos.ap-beijing.myqcloud.com/cs224n/202009/16/104037-896668.png)

原理：对于每一个查询词项，对于其倒排序表中的每一个文档累加该词项的权重。最后比较所有参与过计算的文档的权重和，选出前K个文档。